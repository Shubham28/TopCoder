#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <map>
#include <set>
#include <numeric>

#define FOR(A,B,C) for(int A=B;A<C;A++)
#define EFOR(A,B,C) for(int A=B;A<=C;A++)
#define RFOR(A,B,C) for(int A=B;A>=C;A--)
#define MEM(A,B) memset(A,B,sizeof(A))
#define SZ(A) int(A.size())
#define ALL(A) A.begin(),A.end()
#define VI vector<int>
#define LL long long

using namespace std;

class FavouriteDigits {
public:
	long long findNext(long long, int, int, int, int);

//	Semi-brute force method of Editorial

	int d1,c1,d2,c2;
	int L,MX;
	char conv[18];
	char prm[18],orig[18],copy[18];

//	Calculates a possible solution with length=MX+1
	LL posbMaximum() {
		int cn1=(d1==1)?((c1>0)?c1-1:0):c1;
		int cn2=(d2==1)?((c2>0)?c2-1:0):c2;

		int bk=16;
		FOR(rv,0,cn2)		conv[bk--]='0'+d2;
		FOR(rv,0,cn1)		conv[bk--]='0'+d1;

		if(cn1+cn2<MX)
			FOR(rv,0,MX-(cn1+cn2))
				conv[bk--]='0';

		conv[bk--]='1';
		for(;bk>=0;bk--)
			conv[bk]='0';

		return atoll(conv);
	}

	void firstComb(char prm[18]) {
		int ps=0;

		FOR(qs,0,MX-(c1+c2))		prm[ps++]='#';
		FOR(d,0,c1)					prm[ps++]='0'+d1;
		FOR(d,0,c2)					prm[ps++]='0'+d2;
	}

	LL mnVal(int pos, bool eq) {
		if(pos==MX)
			return atoll(copy);

		if(!eq){
			copy[pos]=(prm[pos]=='#')?'0':prm[pos];
			return mnVal(pos+1,eq);
		}

		if(prm[pos]=='#'){
			copy[pos]=orig[pos];
			LL bst=mnVal(pos+1,eq);
			if(bst!=-1)
				return bst;

			for(char u=orig[pos]+1;u<='9';u++){
				copy[pos]=u;
				bst=mnVal(pos+1,!eq);
				if(bst!=-1)
					return bst;
			}
		} else {
			if(prm[pos]<orig[pos])
				return -1;

			copy[pos]=prm[pos];
			return ((prm[pos]==orig[pos])?mnVal(pos+1,eq):mnVal(pos+1,!eq));
		}
	}
};

long long FavouriteDigits::findNext(long long N, int dig1, int cnt1, int dig2, int cnt2) {
	d1=dig1,d2=dig2;
	c1=cnt1,c2=cnt2;

	if(d1>d2){
		swap(d1,d2);	swap(c1,c2);
	}

	sprintf(conv,"%lld",N);
	L=strlen(conv);
	MX=(c1+c2)>?L;

	LL ret=posbMaximum();

	sprintf(orig,"%lld",N);
	int dif=MX-L;
	EFOR(p,1,L)
		orig[L+dif-p]=orig[L-p];

	FOR(p,0,dif)		orig[p]='0';

	MEM(prm,0);			MEM(copy,0);

	firstComb(prm);
	while(true){
		int i=-1,j;

		LL tmp=mnVal(0,1);
		if(tmp>0 && prm[0]!='0')
			ret<?=tmp;

		RFOR(rv,MX-2,0)
			if(prm[rv]<prm[rv+1]){
				i=rv;
				break;
			}

		if(i==-1)
			break;

		RFOR(rv,MX-1,0)
			if(prm[i]<prm[rv]){
				j=rv;
				break;
			}

		swap(prm[i],prm[j]);
		for(int p=1;i+p<MX-p;p++)
			swap(prm[i+p],prm[MX-p]);
	}
	return ret;
}
// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, long long p0, int p1, int p2, int p3, int p4, bool hasAnswer, long long p5) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2 << "," << p3 << "," << p4;
	cout << "]" << endl;
	FavouriteDigits *obj;
	long long answer;
	obj = new FavouriteDigits();
	clock_t startTime = clock();
	answer = obj->findNext(p0, p1, p2, p3, p4);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p5 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p5;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	long long p0;
	int p1;
	int p2;
	int p3;
	int p4;
	long long p5;

	{
	// ----- test 0 -----
	p0 = 47ll;
	p1 = 1;
	p2 = 0;
	p3 = 2;
	p4 = 0;
	p5 = 47ll;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 47ll;
	p1 = 5;
	p2 = 0;
	p3 = 9;
	p4 = 1;
	p5 = 49ll;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 47ll;
	p1 = 5;
	p2 = 0;
	p3 = 3;
	p4 = 1;
	p5 = 53ll;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}

	{
	// ----- test 3 -----
	p0 = 47ll;
	p1 = 2;
	p2 = 1;
	p3 = 0;
	p4 = 2;
	p5 = 200ll;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}

	{
	// ----- test 4 -----
	p0 = 123456789012345ll;
	p1 = 1;
	p2 = 2;
	p3 = 2;
	p4 = 4;
	p5 = 123456789012422ll;
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	p0 = 92ll;
	p1 = 1;
	p2 = 1;
	p3 = 0;
	p4 = 0;
	p5 = 100ll;
	all_right = KawigiEdit_RunTest(5, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}

	{
	// ----- test 6 -----
	p0 = 223ll;
	p1 = 2;
	p2 = 2;
	p3 = 1;
	p4 = 1;
	p5 = 1022ll;
	all_right = KawigiEdit_RunTest(6, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}

	{
	// ----- test 7 -----
	p0 = 777ll;
	p1 = 7;
	p2 = 14;
	p3 = 0;
	p4 = 1;
	p5 = 707777777777777ll;
	all_right = KawigiEdit_RunTest(7, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}

	{
	// ----- test 8 -----
	p0 = 1ll;
	p1 = 0;
	p2 = 1;
	p3 = 1;
	p4 = 0;
	p5 = 10ll;
	all_right = KawigiEdit_RunTest(8, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
// Author: Shubham Gupta
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
