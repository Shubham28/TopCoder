#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <map>
#include <set>
#include <numeric>

#define FOR(A,B,C) for(int A=B;A<C;A++)
#define EFOR(A,B,C) for(int A=B;A<=C;A++)
#define RFOR(A,B,C) for(int A=B;A>=C;A--)
#define MEM(A,B) memset(A,B,sizeof(A))
#define SZ(A) int(A.size())
#define PB(A,B) A.push_back(B);
#define SORT(A) sort( A.begin(),A.end() )
#define ALL(A) A.begin(),A.end()
#define VI vector<int>
#define VS vector<string>
#define LL long long

using namespace std;

class CakeParty {
public:
	string makeMove(vector <int>);

	VI pcs;
	int L;

	void bstLex(int num, char ret[15]) {
		char conv[15];
		ret[0]='Z',ret[1]=0;

		FOR(i,0,L)
			if(pcs[i]==num){
				sprintf(conv,"%d",i);
				if(strcmp(ret,conv)>0)
					strcpy(ret,conv);
			}
	}
};

string CakeParty::makeMove(vector <int> pcs_) {
	pcs=pcs_,L=SZ(pcs);
	char conv[15];
	if(L==1){
		sprintf(conv,"%d",pcs[0]);
		return "CAKE 0 PIECES "+string(conv);
	}

	int mx=*max_element(ALL(pcs));
	int mxCnt=count(ALL(pcs),mx);

	string val="Z";
	if(mxCnt&1){
		char opt[16];
		bstLex(mx,opt);

		if(mxCnt>1)		val="1";
		else {
			int mx2=0,tot=0;
			FOR(i,0,L){
				if(pcs[i]!=mx && mx2<pcs[i])
					mx2=pcs[i],tot=1;
				else if(pcs[i]!=mx && mx2==pcs[i])
					tot++;
			}

			if(tot&1){
				sprintf(conv,"%d",mx-mx2);
				val=string(conv);
			} else {
				char mnVal[15],mxVal[5];
				int L1;
				sprintf(mnVal,"%d",1+(mx-mx2));
				sprintf(mxVal,"%d",mx);

				if((L1=strlen(mnVal))<strlen(mxVal)){
					val="1";
					FOR(i,0,L1)		val+="0";
				}
				val=min(val,string(mnVal));
			}
		}
		char ans[15];
		sprintf(ans,"CAKE %s PIECES %s",opt,val.c_str());
		return string(ans);
	} else {
		val="Z";
		FOR(i,0,L)
			if(pcs[i]==mx){
				sprintf(conv,"%d",i);
				val=min(val,string(conv));
			}

		return "CAKE "+val+" PIECES 1";
	}
}
// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, bool hasAnswer, string p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}";
	cout << "]" << endl;
	CakeParty *obj;
	string answer;
	obj = new CakeParty();
	clock_t startTime = clock();
	answer = obj->makeMove(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p1 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	string p1;
	
	{
	// ----- test 0 -----
	int t0[] = {47};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "CAKE 0 PIECES 47";
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {3,3};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "CAKE 0 PIECES 1";
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {3,5};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "CAKE 1 PIECES 2";
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "CAKE 0 PIECES 1";
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {3,3,112};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "CAKE 2 PIECES 110";
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	int t0[] = {3,3,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "CAKE 0 PIECES 1";
	all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 6 -----
	int t0[] = {4,7,4,7,4,7,4,7,47,47,47,47};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "CAKE 10 PIECES 1";
	all_right = KawigiEdit_RunTest(6, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 7 -----
	int t0[] = {1501262996,523924202,349689938,203102096,638422091,452180388,1501263104,588219757,1057418419,321826424,625032173,1469262010,298625211,1057467588,54056313,476667373,260401256,1501262996,499966916,1335939812,1501262996,1501262996,1414829151,555996659,1501262996,1501262996,1501262996,1501262996,505548984,570073851};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "CAKE 6 PIECES 1000";
	all_right = KawigiEdit_RunTest(7, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 8 -----
	int t0[] = {1,205,196,196};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "CAKE 1 PIECES 10";
	all_right = KawigiEdit_RunTest(8, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
// Author: Shubham Gupta
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
